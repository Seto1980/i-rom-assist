<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIæ‰‹æŒ‡å¯å‹•åŸŸæ¤œæŸ»ã‚¢ã‚·ã‚¹ãƒˆ v29</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { font-family: sans-serif; text-align: center; background-color: black; margin: 0; padding: 0; color: white; overflow: hidden; }
        
        /* ã‚³ãƒ³ãƒ†ãƒŠï¼šãƒ“ãƒ‡ã‚ªã¨ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’é‡ã­ã‚‹ */
        .container { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 1;
        }
        video { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            object-fit: cover; transform: scaleX(-1); /* è‡ªæ’®ã‚Šç”¨åè»¢ã‚’é˜²ããŸã‚ã€å¿…è¦ãªã‚‰JSã§åˆ¶å¾¡ã™ã‚‹ãŒä»Šå›ã¯å¤–ã‚«ãƒ¡ãƒ©ãªã®ã§åè»¢ã—ãªã„ */
        }
        /* å¤–ã‚«ãƒ¡ãƒ©ã¯åè»¢ã•ã›ãªã„ */
        video.environment { transform: scaleX(1); }

        canvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            object-fit: cover;
        }
        
        /* ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼ˆã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ãƒ»ãƒ¢ãƒ¼ãƒ‰é¸æŠï¼‰ */
        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8); 
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 9999; /* æœ€å‰é¢ */
            backdrop-filter: blur(5px);
        }
        
        #init_view, #mode_view { display: flex; flex-direction: column; align-items: center; gap: 20px; width: 100%; }
        #mode_view { display: none; }

        /* ãƒœã‚¿ãƒ³é¡ */
        #camera_start_btn {
            padding: 20px 50px; font-size: 1.5rem; font-weight: bold;
            background-color: #28a745; color: white; border: none; border-radius: 50px;
            cursor: pointer; box-shadow: 0 4px 15px rgba(40, 167, 69, 0.6);
        }
        .mode-btn {
            width: 80%; max-width: 300px; padding: 18px; font-size: 1.1rem; font-weight: bold;
            background-color: rgba(50, 50, 50, 0.8); color: white; 
            border: 2px solid #00d2ff; border-radius: 12px; cursor: pointer;
        }
        .mode-btn small { display: block; font-size: 0.8rem; color: #ccc; margin-top: 5px; }

        /* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º */
        .status-display {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8); padding: 10px 20px; border-radius: 30px;
            color: #00ff00; font-size: 1.2rem; font-weight: bold;
            z-index: 5000; display: none; white-space: nowrap;
        }

        /* ã‚­ãƒ£ãƒ³ã‚»ãƒ«ãƒœã‚¿ãƒ³ */
        .cancel-btn {
            position: fixed; top: 20px; right: 20px;
            background: rgba(220, 53, 69, 0.9); color: white; border: none; padding: 10px 20px;
            border-radius: 20px; font-weight: bold; z-index: 5001; cursor: pointer; display: none;
        }

        /* çµæœç”»é¢ */
        .result-panel {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: white; z-index: 10000; overflow-y: auto;
            display: none; padding-bottom: 50px; color: #333;
        }
        .result-header { background: #007bff; color: white; padding: 20px; font-size: 1.3rem; font-weight: bold; }
        .result-table { width: 95%; border-collapse: collapse; margin: 20px auto; font-size: 0.9rem; }
        .result-table th, .result-table td { border: 1px solid #ddd; padding: 8px 4px; text-align: center; }
        .result-table th { background-color: #f2f2f2; color: #333; }
        .restart-btn {
            margin: 30px auto; padding: 15px 50px; background: #6c757d; color: white;
            border: none; border-radius: 5px; font-size: 1.2rem; display: block;
        }
        
        #loading_msg { margin-top: 20px; color: #00d2ff; }
    </style>
</head>
<body>

    <div id="start_overlay" class="overlay">
        <div id="init_view">
            <h2 style="margin-bottom:30px;">AIæ‰‹æŒ‡å¯å‹•åŸŸæ¤œæŸ» v29</h2>
            <button id="camera_start_btn" onclick="initCamera()">ğŸ“· ã‚«ãƒ¡ãƒ©ã‚’èµ·å‹•</button>
            <div id="loading_msg"></div>
        </div>

        <div id="mode_view">
            <h2 style="margin-bottom:20px;">æ¸¬å®šãƒ¢ãƒ¼ãƒ‰é¸æŠ</h2>
            <button class="mode-btn" onclick="selectMode('active')">
                è‡ªå‹•é‹å‹•ã®ã¿<small>Active Motion (TAM)</small>
            </button>
            <button class="mode-btn" onclick="selectMode('passive')">
                ä»–å‹•é‹å‹•ã®ã¿<small>Passive Motion (TPM)</small>
            </button>
            <button class="mode-btn" onclick="selectMode('both')">
                è‡ªå‹• ï¼† ä»–å‹•<small>Active & Passive</small>
            </button>
        </div>
    </div>

    <div id="status_display" class="status-display"></div>
    <button id="cancel_btn" class="cancel-btn" onclick="forceFinish()">â–  è¨ˆæ¸¬çµ‚äº†</button>

    <div class="container">
        <video id="input_video" class="environment" playsinline muted autoplay></video>
        <canvas id="output_canvas"></canvas>
    </div>

    <div id="result_panel" class="result-panel">
        <div class="result-header">è¨ˆæ¸¬çµæœ</div>
        <div id="result_container"></div>
        <button class="restart-btn" onclick="location.reload()">ã‚‚ã†ä¸€åº¦è¨ˆæ¸¬ã™ã‚‹</button>
    </div>

<script>
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const startOverlay = document.getElementById('start_overlay');
    const initView = document.getElementById('init_view');
    const modeView = document.getElementById('mode_view');
    const statusDisplay = document.getElementById('status_display');
    const cancelBtn = document.getElementById('cancel_btn');
    const resultPanel = document.getElementById('result_panel');
    const resultContainer = document.getElementById('result_container');
    const loadingMsg = document.getElementById('loading_msg');

    let selectedMode = ''; 
    let currentPhase = 'idle';
    let activeData = createEmptyData();
    let passiveData = createEmptyData();
    let currentDataRef = activeData; 
    let measurementTimer = null;

    // â˜…ã‚«ãƒ¡ãƒ©èµ·å‹•å‡¦ç†ï¼ˆæ‰‹å‹•getUserMediaï¼‰
    async function initCamera() {
        loadingMsg.innerText = "ã‚«ãƒ¡ãƒ©ã‚’èµ·å‹•ä¸­...";
        try {
            // ã“ã“ã§æ˜ç¢ºã«ã€Œenvironmentï¼ˆèƒŒé¢ï¼‰ã€ã‚’æŒ‡å®š
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { 
                    facingMode: "environment", 
                    width: { ideal: 1280 }, 
                    height: { ideal: 720 } 
                } 
            });
            videoElement.srcObject = stream;
            
            videoElement.onloadedmetadata = () => {
                videoElement.play();
                loadingMsg.innerText = "AIãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ä¸­... (ãŠå¾…ã¡ãã ã•ã„)";
                
                // AIãƒ«ãƒ¼ãƒ—é–‹å§‹
                processVideo();
                
                // ç”»é¢åˆ‡ã‚Šæ›¿ãˆ
                initView.style.display = 'none';
                modeView.style.display = 'flex';
            };
        } catch (e) {
            console.error(e);
            alert("ã‚«ãƒ¡ãƒ©èµ·å‹•ã‚¨ãƒ©ãƒ¼: " + e.message);
            loadingMsg.innerText = "ã‚¨ãƒ©ãƒ¼: å†èª­ã¿è¾¼ã¿ã—ã¦ãã ã•ã„";
        }
    }

    // â˜…MediaPipeåˆæœŸåŒ–
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ 
        maxNumHands: 1, 
        modelComplexity: 1, 
        minDetectionConfidence: 0.5, 
        minTrackingConfidence: 0.5 
    });
    hands.onResults(onResults);

    // â˜…æ‰‹å‹•ãƒ«ãƒ¼ãƒ—å‡¦ç†ï¼ˆä¸€ç•ªç¢ºå®Ÿãªæ–¹æ³•ï¼‰
    async function processVideo() {
        if (videoElement.paused || videoElement.ended) {
            requestAnimationFrame(processVideo);
            return;
        }
        try {
            await hands.send({image: videoElement});
        } catch(e) {
            console.error("AI Error:", e);
        }
        requestAnimationFrame(processVideo);
    }

    function createEmptyData() {
        return {
            thumb:  { name:"æ¯æŒ‡", joints: { cm:{val:0, flex:0, ext:999}, mp:{val:0, flex:0, ext:999}, ip:{val:0, flex:0, ext:999} } },
            index:  { name:"ç¤ºæŒ‡", joints: { mp:{val:0, flex:0, ext:999}, pip:{val:0, flex:0, ext:999}, dip:{val:0, flex:0, ext:999} } },
            middle: { name:"ä¸­æŒ‡", joints: { mp:{val:0, flex:0, ext:999}, pip:{val:0, flex:0, ext:999}, dip:{val:0, flex:0, ext:999} } },
            ring:   { name:"ç’°æŒ‡", joints: { mp:{val:0, flex:0, ext:999}, pip:{val:0, flex:0, ext:999}, dip:{val:0, flex:0, ext:999} } },
            pinky:  { name:"å°æŒ‡", joints: { mp:{val:0, flex:0, ext:999}, pip:{val:0, flex:0, ext:999}, dip:{val:0, flex:0, ext:999} } }
        };
    }

    function speakAsync(text) {
        return new Promise((resolve) => {
            if(currentPhase === 'finished') return;
            speechSynthesis.cancel();
            const uttr = new SpeechSynthesisUtterance(text);
            uttr.lang = "ja-JP";
            const timeoutMs = (text.length * 250) + 1500; 
            const safeTimer = setTimeout(() => { resolve(); }, timeoutMs);
            uttr.onend = () => { clearTimeout(safeTimer); resolve(); };
            uttr.onerror = () => { clearTimeout(safeTimer); resolve(); };
            speechSynthesis.speak(uttr);
        });
    }

    function selectMode(mode) {
        selectedMode = mode;
        startOverlay.style.display = 'none'; // ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’æ¶ˆã™
        cancelBtn.style.display = 'block';   // ã‚­ãƒ£ãƒ³ã‚»ãƒ«ãƒœã‚¿ãƒ³è¡¨ç¤º
        if (mode === 'both') {
            startMeasurementSequence('active'); 
        } else {
            startMeasurementSequence(mode);
        }
    }

    function forceFinish() {
        if (measurementTimer) clearInterval(measurementTimer);
        speechSynthesis.cancel();
        finishAll();
    }

    async function startMeasurementSequence(type) {
        if(currentPhase === 'finished') return;
        statusDisplay.style.display = 'block';
        currentDataRef = (type === 'active') ? activeData : passiveData;
        
        let introText = (type === 'active') 
            ? "è‡ªå‹•é‹å‹•ã‚’è¨ˆæ¸¬ã—ã¾ã™ã€‚ã¾ãšã¯å‰è…•ã‚’æ¨ªã«ã—ã¦ãã ã•ã„ã€‚ã—ã£ã‹ã‚Šæ¡ã‚‹ã€ã—ã£ã‹ã‚Šä¼¸ã°ã™ã‚’ç¹°ã‚Šè¿”ã—ã¦ãã ã•ã„ã€‚ç¤ºæŒ‡å´ã‹ã‚‰æ’®å½±ã—ãŸå¾Œã«ã€ã—ã‚‡ã†ã—ãŒã‚ã®æ’®å½±ã‚’ã—ã¾ã™ã€‚æœ€å¾Œã«æ¯æŒ‡ã‚’æ’®å½±ã—ã¾ã™ã€‚" 
            : "ä»–å‹•é‹å‹•ã‚’è¨ˆæ¸¬ã—ã¾ã™ã€‚ã¾ãšã¯å‰è…•ã‚’æ¨ªã«ã—ã¦ãã ã•ã„ã€‚åŠ›ã‚’æŠœã„ã¦ãã ã•ã„ã€‚ç¤ºæŒ‡å´ã‹ã‚‰æ’®å½±ã—ãŸå¾Œã«ã€ã—ã‚‡ã†ã—ãŒã‚ã®æ’®å½±ã‚’ã—ã¾ã™ã€‚æœ€å¾Œã«æ¯æŒ‡ã‚’æ’®å½±ã—ã¾ã™ã€‚";
        
        statusDisplay.innerText = "ã‚¢ãƒŠã‚¦ãƒ³ã‚¹ä¸­...";
        await speakAsync(introText);
        if(currentPhase === 'finished') return;
        
        await speakAsync("ãã‚Œã§ã¯ã€ç¤ºæŒ‡å´ã‹ã‚‰è¨ˆæ¸¬ã‚’é–‹å§‹ã—ã¾ã™ã€‚10ç§’é–“ã€4æœ¬ã®æŒ‡ã‚’å‹•ã‹ã—ã¦ãã ã•ã„ã€‚");
        if(currentPhase === 'finished') return;

        currentPhase = 'measuring_radial';
        await runTimer(type, "ç¤ºæŒ‡ãƒ»ä¸­æŒ‡", 10);
        
        if(currentPhase === 'finished') return;
        currentPhase = 'idle';
        statusDisplay.innerText = "æº–å‚™ä¸­...";
        
        await speakAsync("ã¤ãã«ã€ã—ã‚‡ã†ã—ãŒã‚ã‹ã‚‰è¨ˆæ¸¬ã‚’ã—ã¾ã™ã€‚ã—ã‚‡ã†ã—ãŒã‚ã‹ã‚‰ã‚«ãƒ¡ãƒ©ã‚’å‘ã‘ã¦ãã ã•ã„ã€‚");
        if(currentPhase === 'finished') return;

        await speakAsync("10ç§’é–“ã€4æœ¬ã®æŒ‡ã‚’å‹•ã‹ã—ã¦ãã ã•ã„ã€‚");
        if(currentPhase === 'finished') return;
        
        currentPhase = 'measuring_ulnar';
        await runTimer(type, "ç’°æŒ‡ãƒ»å°æŒ‡", 10);

        if(currentPhase === 'finished') return;
        currentPhase = 'idle';
        statusDisplay.innerText = "æº–å‚™ä¸­...";
        
        await speakAsync("æ¬¡ã«ã€å‰è…•ã‚’ã‹ã„ãŒã„ã—ã¦ãã ã•ã„ã€‚ãã—ã¦æ¯æŒ‡ã‚’5ç§’é–“å‹•ã‹ã—ã¦ãã ã•ã„ã€‚");
        if(currentPhase === 'finished') return;
        
        currentPhase = 'measuring_thumb';
        await runTimer(type, "æ¯æŒ‡", 5);

        if(currentPhase === 'finished') return;
        currentPhase = 'idle';
        
        if (selectedMode === 'both' && type === 'active') {
            speakAsync("è‡ªå‹•é‹å‹•ãŒçµ‚äº†ã—ã¾ã—ãŸã€‚ç¶šã„ã¦ä»–å‹•é‹å‹•ã«ç§»ã‚Šã¾ã™ã€‚").then(() => {
                if(currentPhase !== 'finished') {
                    setTimeout(() => { startMeasurementSequence('passive'); }, 1000);
                }
            });
        } else {
            finishAll();
        }
    }

    function runTimer(type, label, seconds) {
        return new Promise(resolve => {
            let timeLeft = seconds;
            measurementTimer = setInterval(() => {
                const modeLabel = (type === 'active' ? "è‡ªå‹•" : "ä»–å‹•");
                statusDisplay.innerText = `${modeLabel}: ${label} è¨ˆæ¸¬ä¸­ (${timeLeft})`;
                timeLeft--;
                if (timeLeft < 0) {
                    clearInterval(measurementTimer);
                    resolve();
                }
            }, 1000);
        });
    }

    function finishAll() {
        currentPhase = 'finished';
        cancelBtn.style.display = 'none';
        statusDisplay.style.display = 'none';
        
        // â˜…é‡è¦: çµæœãƒ‘ãƒãƒ«ã‚’å¼·åˆ¶çš„ã«æœ€å‰é¢ã¸
        resultPanel.style.display = 'block';
        
        const uttr = new SpeechSynthesisUtterance("è¨ˆæ¸¬ã‚’çµ‚äº†ã—ã¾ã™ã€‚");
        uttr.lang = "ja-JP";
        speechSynthesis.speak(uttr);
        
        showResults();
    }

    function calculateAngle(a, b, c) {
        const radians = Math.atan2(c.y - b.y, c.x - b.x) - Math.atan2(a.y - b.y, a.x - b.x);
        let angle = radians * 180.0 / Math.PI;
        if (angle > 180.0) angle -= 360.0;
        if (angle < -180.0) angle += 360.0;
        let result = 180 - Math.abs(angle); 
        if (result > -2 && result < 2) return 0;
        return result; 
    }

    function applyFilter(currentVal, newVal, jointType) {
        let alpha = 0.3; 
        if (jointType === 'dip' || jointType === 'ip') alpha = 0.15; 
        if (currentVal === 0 && newVal > 0) return newVal;
        return currentVal * (1 - alpha) + newVal * alpha;
    }

    function updateJointData(fingerKey, jointKey, rawAngle) {
        const j = currentDataRef[fingerKey].joints[jointKey];
        j.val = applyFilter(j.val, rawAngle, jointKey);
        let displayVal = Math.round(j.val / 2) * 2;
        if (displayVal <= 4 && displayVal >= -4) displayVal = 0;
        if (displayVal > j.flex) j.flex = displayVal;
        if (displayVal < j.ext) j.ext = displayVal;
    }

    function onResults(results) {
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        
        if (currentPhase !== 'finished' && results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const targetIdx = findCenterHandIndex(results.multiHandLandmarks);
            const lm = results.multiHandLandmarks[targetIdx];

            drawConnectors(canvasCtx, lm, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
            drawLandmarks(canvasCtx, lm, {color: '#FF0000', lineWidth: 1});

            if (currentPhase === 'measuring_radial') {
                updateJointData('index', 'mp',  calculateAngle(lm[0], lm[5], lm[6]));
                updateJointData('index', 'pip', calculateAngle(lm[5], lm[6], lm[7]));
                updateJointData('index', 'dip', calculateAngle(lm[6], lm[7], lm[8]));
                updateJointData('middle', 'mp',  calculateAngle(lm[0], lm[9], lm[10]));
                updateJointData('middle', 'pip', calculateAngle(lm[9], lm[10], lm[11]));
                updateJointData('middle', 'dip', calculateAngle(lm[10], lm[11], lm[12]));
            }
            if (currentPhase === 'measuring_ulnar') {
                updateJointData('ring', 'mp',  calculateAngle(lm[0], lm[13], lm[14]));
                updateJointData('ring', 'pip', calculateAngle(lm[13], lm[14], lm[15]));
                updateJointData('ring', 'dip', calculateAngle(lm[14], lm[15], lm[16]));
                updateJointData('pinky', 'mp',  calculateAngle(lm[0], lm[17], lm[18]));
                updateJointData('pinky', 'pip', calculateAngle(lm[17], lm[18], lm[19]));
                updateJointData('pinky', 'dip', calculateAngle(lm[18], lm[19], lm[20]));
            }
            if (currentPhase === 'measuring_thumb') {
                updateJointData('thumb', 'cm', calculateAngle(lm[0], lm[1], lm[2])); 
                updateJointData('thumb', 'mp', calculateAngle(lm[1], lm[2], lm[3]));
                updateJointData('thumb', 'ip', calculateAngle(lm[2], lm[3], lm[4]));
            }
        }
        canvasCtx.restore();
    }
    
    function findCenterHandIndex(landmarksArray) {
        if (landmarksArray.length === 1) return 0;
        let minD = 999;
        let idx = 0;
        for(let i=0; i<landmarksArray.length; i++){
            const wrist = landmarksArray[i][0];
            const d = Math.sqrt((wrist.x-0.5)**2 + (wrist.y-0.5)**2);
            if(d < minD) { minD = d; idx = i; }
        }
        return idx;
    }

    function showResults() {
        let html = "";
        html += `<table class="result-table"><thead><tr><th rowspan="2">æŒ‡</th><th rowspan="2">é–¢ç¯€</th>`;
        if (selectedMode === 'both') {
            html += `<th colspan="2">è‡ªå‹• (Active)</th><th colspan="2">ä»–å‹• (Passive)</th></tr><tr><th>å±ˆ/ä¼¸</th><th>TAM</th><th>å±ˆ/ä¼¸</th><th>TPM</th></tr>`;
        } else if (selectedMode === 'active') {
            html += `<th colspan="2">è‡ªå‹• (Active)</th></tr><tr><th>å±ˆ/ä¼¸</th><th>TAM</th></tr>`;
        } else {
            html += `<th colspan="2">ä»–å‹• (Passive)</th></tr><tr><th>å±ˆ/ä¼¸</th><th>TPM</th></tr>`;
        }
        html += `</thead><tbody>`;

        const tA = activeData.thumb;
        const tP = passiveData.thumb;
        const tA_tam = calcTamThumb(tA);
        const tP_tam = calcTamThumb(tP);

        html += generateRowThumb(tA, tP, tA_tam, tP_tam, 'CM');
        html += generateRowThumb(tA, tP, tA_tam, tP_tam, 'MP');
        html += generateRowThumb(tA, tP, tA_tam, tP_tam, 'IP');

        ['index', 'middle', 'ring', 'pinky'].forEach(key => {
            const fA = activeData[key];
            const fP = passiveData[key];
            const fA_tam = calcTamFinger(fA);
            const fP_tam = calcTamFinger(fP);
            
            html += generateRowFinger(fA, fP, fA_tam, fP_tam, 'MP');
            html += generateRowFinger(fA, fP, fA_tam, fP_tam, 'PIP');
            html += generateRowFinger(fA, fP, fA_tam, fP_tam, 'DIP');
        });

        html += `</tbody></table>`;
        resultContainer.innerHTML = html;
    }

    function calcTamThumb(data) {
        const mp_deficit = Math.max(0, data.joints.mp.ext);
        const ip_deficit = Math.max(0, data.joints.ip.ext);
        return Math.max(0, data.joints.mp.flex - mp_deficit) + Math.max(0, data.joints.ip.flex - ip_deficit);
    }

    function calcTamFinger(data) {
        const mp_deficit = Math.max(0, data.joints.mp.ext);
        const pip_deficit = Math.max(0, data.joints.pip.ext);
        const dip_deficit = Math.max(0, data.joints.dip.ext);
        return Math.max(0, data.joints.mp.flex - mp_deficit) + Math.max(0, data.joints.pip.flex - pip_deficit) + Math.max(0, data.joints.dip.flex - dip_deficit);
    }

    function formatExt(val) {
        if (val > 900) return "-"; 
        if (val > 0) return `-${val}Â°`; 
        if (val === 0) return `0Â°`;
        return `+${Math.abs(val)}Â°`; 
    }

    function generateRowThumb(dA, dP, tamA, tamP, joint) {
        let h = `<tr>`; 
        if(joint==='CM') h += `<td rowspan="3">${dA.name}</td>`;
        h += `<td>${joint}</td>`;
        if(selectedMode !== 'passive') {
            h += `<td>${dA.joints[joint.toLowerCase()].flex}Â° / ${formatExt(dA.joints[joint.toLowerCase()].ext)}</td>`;
            if(joint==='MP') h += `<td rowspan="2">${tamA}Â°</td>`;
            else if(joint==='CM') h += `<td>-</td>`;
        }
        if(selectedMode !== 'active') {
             h += `<td>${dP.joints[joint.toLowerCase()].flex}Â° / ${formatExt(dP.joints[joint.toLowerCase()].ext)}</td>`;
             if(joint==='MP') h += `<td rowspan="2">${tamP}Â°</td>`; 
             else if(joint==='CM') h += `<td>-</td>`;
        }
        h += `</tr>`;
        return h;
    }

    function generateRowFinger(dA, dP, tamA, tamP, joint) {
        let h = `<tr>`;
        if(joint==='MP') h += `<td rowspan="3">${dA.name}</td>`;
        h += `<td>${joint}</td>`;
        if(selectedMode !== 'passive') {
             h += `<td>${dA.joints[joint.toLowerCase()].flex}Â° / ${formatExt(dA.joints[joint.toLowerCase()].ext)}</td>`;
             if(joint==='MP') h += `<td rowspan="3">${tamA}Â°</td>`;
        }
        if(selectedMode !== 'active') {
             h += `<td>${dP.joints[joint.toLowerCase()].flex}Â° / ${formatExt(dP.joints[joint.toLowerCase()].ext)}</td>`;
             if(joint==='MP') h += `<td rowspan="3">${tamP}Â°</td>`; 
        }
        h += `</tr>`;
        return h;
    }
</script>
</body>
</html>