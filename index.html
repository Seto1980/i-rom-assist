<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI手指可動域検査アシスト v23</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { font-family: sans-serif; text-align: center; background-color: black; margin: 0; padding: 0; color: white; }
        .container { position: relative; width: 100%; height: 100vh; overflow: hidden; }
        video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 1; display: block; }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 2; }
        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.4); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 9999; color: white; backdrop-filter: blur(2px); }
        .mode-select-container { display: flex; flex-direction: column; gap: 20px; width: 85%; max-width: 320px; }
        .mode-btn { padding: 18px; font-size: 1.1rem; font-weight: bold; background-color: rgba(0, 0, 0, 0.6); color: white; border: 2px solid #00d2ff; border-radius: 12px; cursor: pointer; transition: all 0.2s; box-shadow: 0 4px 15px rgba(0, 210, 255, 0.3); }
        .mode-btn:active { background-color: #00d2ff; color: black; transform: scale(0.98); }
        .mode-btn small { display: block; font-size: 0.8rem; font-weight: normal; margin-top: 4px; color: #ddd; }
        .status-display { position: fixed; top: 10%; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.8); padding: 12px 24px; border-radius: 30px; color: #00ff00; font-size: 1.2rem; font-weight: bold; z-index: 100; display: none; white-space: nowrap; box-shadow: 0 4px 10px rgba(0,0,0,0.5); }
        .cancel-btn { position: fixed; top: 20px; right: 20px; background: rgba(220, 53, 69, 0.9); color: white; border: none; padding: 10px 20px; border-radius: 20px; font-weight: bold; font-size: 1rem; z-index: 200; cursor: pointer; display: none; box-shadow: 0 4px 8px rgba(0,0,0,0.5); }
        .result-panel { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: white; z-index: 10000; overflow-y: auto; display: none; padding-bottom: 50px; color: #333; }
        .result-header { background: #007bff; color: white; padding: 15px; font-size: 1.2rem; font-weight: bold; }
        .result-table { width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 0.8rem; }
        .result-table th, .result-table td { border: 1px solid #ddd; padding: 8px 4px; text-align: center; }
        .result-table th { background-color: #f2f2f2; color: #333; }
        .restart-btn { margin: 30px auto; padding: 15px 40px; background: #6c757d; color: white; border: none; border-radius: 5px; font-size: 1rem; display: block; }
    </style>
</head>
<body>

    <div id="start_overlay" class="overlay">
        <h2 style="margin-bottom:20px; text-shadow: 1px 1px 5px black;">測定モード選択</h2>
        <div class="mode-select-container">
            <button class="mode-btn" onclick="selectMode('active')">
                自動運動のみ
                <small>Active Motion (TAM)</small>
            </button>
            <button class="mode-btn" onclick="selectMode('passive')">
                他動運動のみ
                <small>Passive Motion (TPM)</small>
            </button>
            <button class="mode-btn" onclick="selectMode('both')">
                自動 ＆ 他動
                <small>Active & Passive</small>
            </button>
        </div>
    </div>

    <div id="status_display" class="status-display"></div>
    <button id="cancel_btn" class="cancel-btn" onclick="forceFinish()">■ 計測終了</button>

    <div class="container">
        <video id="input_video" playsinline muted autoplay></video>
        <canvas id="output_canvas"></canvas>
    </div>

    <div id="result_panel" class="result-panel">
        <div class="result-header">計測結果</div>
        <div id="result_container"></div>
        <button class="restart-btn" onclick="location.reload()">もう一度計測する</button>
    </div>

<script>
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const startOverlay = document.getElementById('start_overlay');
    const statusDisplay = document.getElementById('status_display');
    const cancelBtn = document.getElementById('cancel_btn');
    const resultPanel = document.getElementById('result_panel');
    const resultContainer = document.getElementById('result_container');

    let selectedMode = ''; 
    let currentPhase = 'idle';
    let activeData = createEmptyData();
    let passiveData = createEmptyData();
    let currentDataRef = activeData; 
    let measurementTimer = null;

    function createEmptyData() {
        // ext初期値を999にして、最小値を更新していく
        return {
            thumb:  { name:"母指", joints: { cm:{val:0, flex:0, ext:999}, mp:{val:0, flex:0, ext:999}, ip:{val:0, flex:0, ext:999} } },
            index:  { name:"示指", joints: { mp:{val:0, flex:0, ext:999}, pip:{val:0, flex:0, ext:999}, dip:{val:0, flex:0, ext:999} } },
            middle: { name:"中指", joints: { mp:{val:0, flex:0, ext:999}, pip:{val:0, flex:0, ext:999}, dip:{val:0, flex:0, ext:999} } },
            ring:   { name:"環指", joints: { mp:{val:0, flex:0, ext:999}, pip:{val:0, flex:0, ext:999}, dip:{val:0, flex:0, ext:999} } },
            pinky:  { name:"小指", joints: { mp:{val:0, flex:0, ext:999}, pip:{val:0, flex:0, ext:999}, dip:{val:0, flex:0, ext:999} } }
        };
    }

    function speakAsync(text) {
        return new Promise((resolve) => {
            if(currentPhase === 'finished') return;
            speechSynthesis.cancel();
            const uttr = new SpeechSynthesisUtterance(text);
            uttr.lang = "ja-JP";
            const timeoutMs = (text.length * 250) + 1500; 
            const safeTimer = setTimeout(() => { resolve(); }, timeoutMs);
            uttr.onend = () => { clearTimeout(safeTimer); resolve(); };
            uttr.onerror = () => { clearTimeout(safeTimer); resolve(); };
            speechSynthesis.speak(uttr);
        });
    }

    function selectMode(mode) {
        selectedMode = mode;
        startOverlay.style.display = 'none';
        cancelBtn.style.display = 'block';
        if (mode === 'both') {
            startMeasurementSequence('active'); 
        } else {
            startMeasurementSequence(mode);
        }
    }

    function forceFinish() {
        if (measurementTimer) clearInterval(measurementTimer);
        speechSynthesis.cancel();
        finishAll();
    }

    async function startMeasurementSequence(type) {
        if(currentPhase === 'finished') return;
        statusDisplay.style.display = 'block';
        currentDataRef = (type === 'active') ? activeData : passiveData;
        
        let introText = "";
        if (type === 'active') {
            introText = "自動運動を計測します。まずは前腕を横にしてください。しっかり握る、しっかり伸ばすを繰り返してください。示指側から撮影した後に、小指側の撮影をします。最後に母指を撮影します。";
        } else {
            introText = "他動運動を計測します。まずは前腕を横にしてください。力を抜いてください。示指側から撮影した後に、小指側の撮影をします。最後に母指を撮影します。";
        }
        
        statusDisplay.innerText = "アナウンス中...";
        await speakAsync(introText);
        if(currentPhase === 'finished') return;
        
        await speakAsync("それでは、示指側から計測を開始します。10秒間、4本の指を動かしてください。");
        if(currentPhase === 'finished') return;

        currentPhase = 'measuring_radial';
        await runTimer(type, "示指・中指", 10);
        
        if(currentPhase === 'finished') return;
        currentPhase = 'idle';
        statusDisplay.innerText = "準備中...";
        
        await speakAsync("次に小指側から計測をします。小指側からカメラを向けてください。");
        if(currentPhase === 'finished') return;

        await speakAsync("10秒間、4本の指を動かしてください。");
        if(currentPhase === 'finished') return;
        
        currentPhase = 'measuring_ulnar';
        await runTimer(type, "環指・小指", 10);

        if(currentPhase === 'finished') return;
        currentPhase = 'idle';
        statusDisplay.innerText = "準備中...";
        
        await speakAsync("次に、前腕を回外してください。そして母指を5秒間動かしてください。");
        if(currentPhase === 'finished') return;
        
        currentPhase = 'measuring_thumb';
        await runTimer(type, "母指", 5);

        if(currentPhase === 'finished') return;
        currentPhase = 'idle';
        
        if (selectedMode === 'both' && type === 'active') {
            speakAsync("自動運動が終了しました。続いて他動運動に移ります。").then(() => {
                if(currentPhase !== 'finished') {
                    setTimeout(() => { startMeasurementSequence('passive'); }, 1000);
                }
            });
        } else {
            finishAll();
        }
    }

    function runTimer(type, label, seconds) {
        return new Promise(resolve => {
            let timeLeft = seconds;
            measurementTimer = setInterval(() => {
                const modeLabel = (type === 'active' ? "自動" : "他動");
                statusDisplay.innerText = `${modeLabel}: ${label} 計測中 (${timeLeft})`;
                timeLeft--;
                if (timeLeft < 0) {
                    clearInterval(measurementTimer);
                    resolve();
                }
            }, 1000);
        });
    }

    function finishAll() {
        currentPhase = 'finished';
        cancelBtn.style.display = 'none';
        statusDisplay.style.display = 'none';
        const uttr = new SpeechSynthesisUtterance("計測を終了します。");
        uttr.lang = "ja-JP";
        speechSynthesis.speak(uttr);
        showResults();
    }

    // ★角度計算（マイナス過伸展に対応）
    function calculateAngle(a, b, c) {
        const radians = Math.atan2(c.y - b.y, c.x - b.x) - Math.atan2(a.y - b.y, a.x - b.x);
        let angle = radians * 180.0 / Math.PI;
        
        if (angle > 180.0) angle -= 360.0;
        if (angle < -180.0) angle += 360.0;
        
        // 180度からの変位を計算
        // 正の値＝屈曲、負の値＝過伸展
        let result = 180 - Math.abs(angle);
        
        // ノイズ除去のためのスナップ（±2度は0とみなす）
        if (result > -2 && result < 2) {
            return 0;
        }
        
        return result; 
    }

    function applyFilter(currentVal, newVal, jointType) {
        let alpha = 0.3; 
        if (jointType === 'dip' || jointType === 'ip') alpha = 0.15; 
        if (currentVal === 0 && newVal > 0) return newVal;
        return currentVal * (1 - alpha) + newVal * alpha;
    }

    function updateJointData(fingerKey, jointKey, rawAngle) {
        const j = currentDataRef[fingerKey].joints[jointKey];
        
        // フィルタリング
        j.val = applyFilter(j.val, rawAngle, jointKey);
        
        // 2度単位に丸める
        let displayVal = Math.round(j.val / 2) * 2;

        // 最大値（屈曲）更新
        if (displayVal > j.flex) j.flex = displayVal;
        
        // 最小値（伸展）更新
        if (displayVal < j.ext) j.ext = displayVal;
    }

    // ★TAM計算ロジック（医学的定義準拠）
    // 屈曲 - max(0, 伸展不足分) 
    // ※過伸展(マイナス)は計算に入れない。伸展不足(プラス)は引く。
    // ※データ上のextは、過伸展ならマイナス、伸展不足ならプラスで入っているはず。
    
    function calcTamThumb(data) {
        // ext > 0 なら伸展不足（引く）。 ext <= 0 なら過伸展または正常（引かない＝0）
        const mp_deficit = Math.max(0, data.joints.mp.ext);
        const ip_deficit = Math.max(0, data.joints.ip.ext);
        
        return Math.max(0, data.joints.mp.flex - mp_deficit) + 
               Math.max(0, data.joints.ip.flex - ip_deficit);
    }

    function calcTamFinger(data) {
        const mp_deficit = Math.max(0, data.joints.mp.ext);
        const pip_deficit = Math.max(0, data.joints.pip.ext);
        const dip_deficit = Math.max(0, data.joints.dip.ext);

        return Math.max(0, data.joints.mp.flex - mp_deficit) + 
               Math.max(0, data.joints.pip.flex - pip_deficit) + 
               Math.max(0, data.joints.dip.flex - dip_deficit);
    }

    // ★表示用フォーマッター
    function formatExt(val) {
        if (val > 900) return "-"; // 初期値のまま
        if (val > 0) return `-${val}°`; // 伸展不足（例：30度曲がってる → -30表記）
        if (val === 0) return `0°`;
        return `+${Math.abs(val)}°`; // 過伸展（例：-10度 → +10表記）
    }

    function generateRowThumb(dA, dP, tamA, tamP, joint) {
        let h = `<tr>`; 
        if(joint==='CM') h += `<td rowspan="3">${dA.name}</td>`;
        h += `<td>${joint}</td>`;
        
        if(selectedMode !== 'passive') {
            h += `<td>${dA.joints[joint.toLowerCase()].flex}° / ${formatExt(dA.joints[joint.toLowerCase()].ext)}</td>`;
            if(joint==='MP') h += `<td rowspan="2">${tamA}°</td>`;
            else if(joint==='CM') h += `<td>-</td>`;
        }
        if(selectedMode !== 'active') {
             h += `<td>${dP.joints[joint.toLowerCase()].flex}° / ${formatExt(dP.joints[joint.toLowerCase()].ext)}</td>`;
             if(joint==='MP') h += `<td rowspan="2">${tamP}°</td>`; 
             else if(joint==='CM') h += `<td>-</td>`;
        }
        h += `</tr>`;
        return h;
    }

    function generateRowFinger(dA, dP, tamA, tamP, joint) {
        let h = `<tr>`;
        if(joint==='MP') h += `<td rowspan="3">${dA.name}</td>`;
        h += `<td>${joint}</td>`;

        if(selectedMode !== 'passive') {
             h += `<td>${dA.joints[joint.toLowerCase()].flex}° / ${formatExt(dA.joints[joint.toLowerCase()].ext)}</td>`;
             if(joint==='MP') h += `<td rowspan="3">${tamA}°</td>`;
        }
        if(selectedMode !== 'active') {
             h += `<td>${dP.joints[joint.toLowerCase()].flex}° / ${formatExt(dP.joints[joint.toLowerCase()].ext)}</td>`;
             if(joint==='MP') h += `<td rowspan="3">${tamP}°</td>`; 
        }
        h += `</tr>`;
        return h;
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(onResults);

    async function startCamera() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
            videoElement.srcObject = stream;
            
            videoElement.onloadedmetadata = () => {
                videoElement.play();
                const sendFrame = async () => {
                    await hands.send({image: videoElement});
                    requestAnimationFrame(sendFrame);
                };
                sendFrame();
            };
        } catch (e) { console.error(e); alert("カメラ起動エラー: " + e.message); }
    }
    startCamera();

    let wakeLock = null;
    async function requestWakeLock() { try { wakeLock = await navigator.wakeLock.request('screen'); } catch (err) {} }
    requestWakeLock();
    document.addEventListener('visibilitychange', async () => { if (wakeLock !== null && document.visibilityState === 'visible') await requestWakeLock(); });
</script>
</body>
</html>