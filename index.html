<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI手指可動域検査アシスト v7</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { font-family: sans-serif; text-align: center; background-color: #f0f4f8; margin: 0; padding: 0; }
        .container { position: relative; width: 100%; max-width: 640px; margin: 0 auto; background: black; overflow: hidden; }
        video { display: none; }
        canvas { width: 100%; height: auto; display: block; }
        
        /* ★固定ガイドライン（前腕合わせ用） */
        .static-guide {
            position: absolute;
            top: 50%; left: 0; width: 100%; height: 4px;
            background: rgba(0, 255, 255, 0.4); /* 水色のライン */
            transform: translateY(-50%);
            pointer-events: none;
            z-index: 5;
        }
        .static-guide::after {
            content: "この線に前腕（橈骨）を合わせてください";
            position: absolute; top: -30px; left: 50%; transform: translateX(-50%);
            color: rgba(0, 255, 255, 0.8); font-weight: bold; font-size: 0.9rem;
            text-shadow: 1px 1px 2px black;
            width: 100%;
        }
        /* 手首の位置マーカー */
        .wrist-marker {
            position: absolute; top: 50%; right: 15%; /* 画面右寄りに手首を置く想定 */
            width: 20px; height: 20px;
            background: rgba(255, 0, 0, 0.5);
            border: 2px solid white; border-radius: 50%;
            transform: translate(50%, -50%);
            z-index: 6;
        }
        .wrist-marker::after {
            content: "手首";
            position: absolute; top: 25px; left: 50%; transform: translateX(-50%);
            color: white; font-size: 0.8rem;
        }

        /* 下部パネル（3関節表示用に拡張） */
        .info-panel { 
            position: fixed; bottom: 0; left: 0; width: 100%; 
            background: rgba(255, 255, 255, 0.95); padding: 10px 0 20px 0; 
            border-top-left-radius: 20px; border-top-right-radius: 20px;
            box-shadow: 0 -4px 10px rgba(0,0,0,0.1);
        }
        h1 { font-size: 1rem; color: #333; margin: 0 0 10px 0; font-weight: bold; }

        /* テーブルデザイン */
        .rom-table {
            width: 95%; margin: 0 auto; border-collapse: collapse; font-size: 0.9rem;
        }
        .rom-table th { background: #e9ecef; padding: 8px; border-radius: 5px; color: #495057; }
        .rom-table td { padding: 5px; text-align: center; border-bottom: 1px solid #dee2e6; }
        .joint-name { font-weight: bold; color: #333; }
        .val-box { font-size: 1.4rem; font-weight: bold; color: #007bff; }
        .max-val { font-size: 0.9rem; color: #666; }
        .unit { font-size: 0.8rem; color: #888; }
        
        .reset-btn { margin-top: 10px; padding: 6px 20px; background-color: #6c757d; color: white; border: none; border-radius: 20px; cursor: pointer; }
    </style>
</head>
<body>

    <div class="container">
        <video id="input_video" playsinline></video>
        <canvas id="output_canvas"></canvas>
        
        <div class="static-guide"></div>
        <div class="wrist-marker"></div>
    </div>
    
    <div class="info-panel">
        <h1>示指 3関節同時測定</h1>
        
        <table class="rom-table">
            <thead>
                <tr>
                    <th>関節</th>
                    <th>現在</th>
                    <th>屈曲MAX</th>
                    <th>伸展MAX</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="joint-name">MP</td>
                    <td><span id="mp_now" class="val-box">--</span></td>
                    <td><span id="mp_flex" class="max-val">0</span></td>
                    <td><span id="mp_ext" class="max-val">--</span></td>
                </tr>
                <tr>
                    <td class="joint-name">PIP</td>
                    <td><span id="pip_now" class="val-box">--</span></td>
                    <td><span id="pip_flex" class="max-val">0</span></td>
                    <td><span id="pip_ext" class="max-val">--</span></td>
                </tr>
                <tr>
                    <td class="joint-name">DIP</td>
                    <td><span id="dip_now" class="val-box">--</span></td>
                    <td><span id="dip_flex" class="max-val">0</span></td>
                    <td><span id="dip_ext" class="max-val">--</span></td>
                </tr>
            </tbody>
        </table>

        <button class="reset-btn" onclick="resetRecords()">記録リセット</button>
    </div>

<script>
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');

    // データ保持用オブジェクト
    const joints = {
        mp:  { now: 0, flex: 0, ext: 999, history: [] },
        pip: { now: 0, flex: 0, ext: 999, history: [] },
        dip: { now: 0, flex: 0, ext: 999, history: [] }
    };
    const SMOOTHING_FRAMES = 5;

    function resetRecords() {
        ['mp', 'pip', 'dip'].forEach(key => {
            joints[key].flex = 0;
            joints[key].ext = 999;
            joints[key].history = [];
            document.getElementById(`${key}_flex`).innerText = "0";
            document.getElementById(`${key}_ext`).innerText = "--";
        });
    }

    // 角度計算 (0度基準)
    function calculateAngle(a, b, c) {
        const radians = Math.atan2(c.y - b.y, c.x - b.x) - Math.atan2(a.y - b.y, a.x - b.x);
        let angle = Math.abs(radians * 180.0 / Math.PI);
        if (angle > 180.0) angle = 360 - angle;
        return 180 - angle;
    }

    function updateJoint(key, p1, p2, p3) {
        const rawAngle = calculateAngle(p1, p2, p3);
        const j = joints[key];
        
        j.history.push(rawAngle);
        if (j.history.length > SMOOTHING_FRAMES) j.history.shift();
        const avg = j.history.reduce((a, b) => a + b, 0) / j.history.length;
        
        // 2度単位
        const displayVal = Math.round(avg / 2) * 2;
        
        // 更新
        document.getElementById(`${key}_now`).innerText = displayVal;
        
        // MAX記録
        if (displayVal > j.flex) {
            j.flex = displayVal;
            document.getElementById(`${key}_flex`).innerText = j.flex;
        }
        if (displayVal < j.ext) {
            j.ext = displayVal;
            document.getElementById(`${key}_ext`).innerText = j.ext;
        }
    }

    function onResults(results) {
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

        if (results.multiHandLandmarks) {
            for (const landmarks of results.multiHandLandmarks) {
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1});

                // 人差し指の関節: 
                // MP  = Wrist(0) -> MP(5) -> PIP(6)
                // PIP = MP(5)    -> PIP(6) -> DIP(7)
                // DIP = PIP(6)   -> DIP(7) -> Tip(8)
                
                updateJoint('mp',  landmarks[0], landmarks[5], landmarks[6]);
                updateJoint('pip', landmarks[5], landmarks[6], landmarks[7]);
                updateJoint('dip', landmarks[6], landmarks[7], landmarks[8]);
            }
        }
        canvasCtx.restore();
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });
    hands.onResults(onResults);

    async function startCamera() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
            videoElement.srcObject = stream;
            videoElement.onloadedmetadata = () => {
                videoElement.play();
                const send = async () => { await hands.send({image: videoElement}); requestAnimationFrame(send); };
                send();
            };
        } catch (e) { alert("カメラエラー: " + e.message); }
    }
    startCamera();

    let wakeLock = null;
    async function requestWakeLock() { try { wakeLock = await navigator.wakeLock.request('screen'); } catch (err) {} }
    requestWakeLock();
    document.addEventListener('visibilitychange', async () => { if (wakeLock !== null && document.visibilityState === 'visible') await requestWakeLock(); });
</script>
</body>
</html>