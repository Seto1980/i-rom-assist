<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI手指可動域検査アシスト v11</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { font-family: sans-serif; text-align: center; background-color: #f0f4f8; margin: 0; padding: 0; }
        .container { position: relative; width: 100%; max-width: 640px; margin: 0 auto; background: black; overflow: hidden; }
        video { display: none; }
        canvas { width: 100%; height: auto; display: block; }
        
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 20; color: white;
        }
        .start-btn {
            padding: 15px 40px; font-size: 1.5rem; font-weight: bold;
            background-color: #007bff; color: white; border: none; border-radius: 50px;
            cursor: pointer; box-shadow: 0 4px 15px rgba(0,123,255,0.5);
            transition: transform 0.2s;
        }
        .start-btn:active { transform: scale(0.95); }
        
        .status-display {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7); padding: 10px 20px; border-radius: 30px;
            color: #00ff00; font-size: 1.2rem; font-weight: bold;
            z-index: 10; display: none; white-space: nowrap;
        }

        .result-panel {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: white; z-index: 30; overflow-y: auto;
            display: none; padding-bottom: 50px;
        }
        .result-header { background: #007bff; color: white; padding: 15px; font-size: 1.2rem; font-weight: bold; }
        .result-table { width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 0.85rem; }
        .result-table th, .result-table td { border: 1px solid #ddd; padding: 6px 4px; text-align: center; }
        .result-table th { background-color: #f2f2f2; color: #333; }
        .finger-row { background-color: #eef2f6; font-weight: bold; }
        .restart-btn {
            margin: 20px auto; padding: 10px 30px; background: #6c757d; color: white;
            border: none; border-radius: 5px; font-size: 1rem; display: block;
        }
    </style>
</head>
<body>

    <div class="container">
        <video id="input_video" playsinline></video>
        <canvas id="output_canvas"></canvas>
        
        <div id="start_overlay" class="overlay">
            <p style="margin-bottom:20px;">手をカメラに向けてください</p>
            <button class="start-btn" onclick="startMeasurementSequence()">計測スタート</button>
        </div>
        <div id="status_display" class="status-display"></div>
    </div>

    <div id="result_panel" class="result-panel">
        <div class="result-header">計測結果</div>
        <table class="result-table" id="result_table_body"></table>
        <button class="restart-btn" onclick="location.reload()">もう一度計測する</button>
    </div>

<script>
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const startOverlay = document.getElementById('start_overlay');
    const statusDisplay = document.getElementById('status_display');
    const resultPanel = document.getElementById('result_panel');
    const resultTableBody = document.getElementById('result_table_body');

    let currentState = 'idle';
    
    // データ保持用
    const fingersData = {
        thumb:  { name:"母指", joints: { cm:{val:0, flex:0, ext:180}, mp:{val:0, flex:0, ext:180}, ip:{val:0, flex:0, ext:180} } },
        index:  { name:"示指", joints: { mp:{val:0, flex:0, ext:180}, pip:{val:0, flex:0, ext:180}, dip:{val:0, flex:0, ext:180} } },
        middle: { name:"中指", joints: { mp:{val:0, flex:0, ext:180}, pip:{val:0, flex:0, ext:180}, dip:{val:0, flex:0, ext:180} } },
        ring:   { name:"環指", joints: { mp:{val:0, flex:0, ext:180}, pip:{val:0, flex:0, ext:180}, dip:{val:0, flex:0, ext:180} } },
        pinky:  { name:"小指", joints: { mp:{val:0, flex:0, ext:180}, pip:{val:0, flex:0, ext:180}, dip:{val:0, flex:0, ext:180} } }
    };

    function speak(text) {
        const uttr = new SpeechSynthesisUtterance(text);
        uttr.lang = "ja-JP";
        speechSynthesis.speak(uttr);
    }

    function startMeasurementSequence() {
        startOverlay.style.display = 'none';
        statusDisplay.style.display = 'block';
        speak("計測を開始します。スタートポジションに合わせてください。では10秒間、4本の指を動かしてみてください");
        statusDisplay.innerText = "4指 計測中 (あと10秒)";
        setTimeout(() => {
            currentState = 'phase1';
            let timeLeft = 10;
            const timer = setInterval(() => {
                timeLeft--;
                statusDisplay.innerText = `4指 計測中 (あと${timeLeft}秒)`;
                if (timeLeft <= 0) {
                    clearInterval(timer);
                    currentState = 'interval';
                    startPhase2();
                }
            }, 1000);
        }, 3000);
    }

    function startPhase2() {
        speak("次に、前腕を回外してください。そして母指を5秒間動かしてください");
        statusDisplay.innerText = "準備中...";
        setTimeout(() => {
            currentState = 'phase2';
            let timeLeft = 5;
            statusDisplay.innerText = `母指 計測中 (あと${timeLeft}秒)`;
            const timer = setInterval(() => {
                timeLeft--;
                statusDisplay.innerText = `母指 計測中 (あと${timeLeft}秒)`;
                if (timeLeft <= 0) {
                    clearInterval(timer);
                    finishMeasurement();
                }
            }, 1000);
        }, 4000);
    }

    function finishMeasurement() {
        currentState = 'finished';
        speak("お疲れ様でした。計測は終了です");
        statusDisplay.style.display = 'none';
        showResults();
    }

    // ★角度計算ロジック
    // 3点 A(固定側)-B(関節)-C(可動側) の角度を算出
    function calculateAngle(a, b, c) {
        const radians = Math.atan2(c.y - b.y, c.x - b.x) - Math.atan2(a.y - b.y, a.x - b.x);
        let angle = Math.abs(radians * 180.0 / Math.PI);
        if (angle > 180.0) angle = 360 - angle;
        return 180 - angle;
    }

    // ★強力なノイズフィルター (Exponential Moving Average)
    // alphaが小さいほど、過去の値を重視して滑らかになる（反応は遅れる）
    function applyFilter(currentVal, newVal, jointType) {
        let alpha = 0.3; // デフォルト (MP, PIP)
        if (jointType === 'dip' || jointType === 'ip') {
            alpha = 0.15; // DIPとIPはブレやすいので、より強く滑らかにする
        }
        
        // 最初の値が入っていない場合はそのまま返す
        if (currentVal === 0 && newVal > 0) return newVal;

        // フィルタ計算: 新しい値 = 現在値 * (1-α) + 新観測値 * α
        return currentVal * (1 - alpha) + newVal * alpha;
    }

    function updateJointData(fingerKey, jointKey, rawAngle) {
        const j = fingersData[fingerKey].joints[jointKey];
        
        // フィルタ適用
        j.val = applyFilter(j.val, rawAngle, jointKey);
        
        // 2度単位に丸める
        const displayVal = Math.round(j.val / 2) * 2;
        
        // 最大・最小更新
        if (displayVal > j.flex) j.flex = displayVal;
        if (displayVal < j.ext) j.ext = displayVal;
    }

    function onResults(results) {
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const lm = results.multiHandLandmarks[0];
            drawConnectors(canvasCtx, lm, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
            drawLandmarks(canvasCtx, lm, {color: '#FF0000', lineWidth: 1});

            if (currentState === 'phase1') {
                // 示指～小指
                // MP: Wrist(0)-MP(5)-PIP(6)  ※中手骨-基節骨
                // PIP: MP(5)-PIP(6)-DIP(7)   ※基節骨-中節骨
                // DIP: PIP(6)-DIP(7)-Tip(8)  ※中節骨-末節骨
                
                // Index
                updateJointData('index', 'mp',  calculateAngle(lm[0], lm[5], lm[6]));
                updateJointData('index', 'pip', calculateAngle(lm[5], lm[6], lm[7]));
                updateJointData('index', 'dip', calculateAngle(lm[6], lm[7], lm[8]));
                // Middle
                updateJointData('middle', 'mp',  calculateAngle(lm[0], lm[9], lm[10]));
                updateJointData('middle', 'pip', calculateAngle(lm[9], lm[10], lm[11]));
                updateJointData('middle', 'dip', calculateAngle(lm[10], lm[11], lm[12]));
                // Ring
                updateJointData('ring', 'mp',  calculateAngle(lm[0], lm[13], lm[14]));
                updateJointData('ring', 'pip', calculateAngle(lm[13], lm[14], lm[15]));
                updateJointData('ring', 'dip', calculateAngle(lm[14], lm[15], lm[16]));
                // Pinky
                updateJointData('pinky', 'mp',  calculateAngle(lm[0], lm[17], lm[18]));
                updateJointData('pinky', 'pip', calculateAngle(lm[17], lm[18], lm[19]));
                updateJointData('pinky', 'dip', calculateAngle(lm[18], lm[19], lm[20]));
            }
            if (currentState === 'phase2') {
                // Thumb (母指)
                // CM: Wrist(0)-CMC(1)-MCP(2)
                updateJointData('thumb', 'cm', calculateAngle(lm[0], lm[1], lm[2])); 
                // MP: CMC(1)-MCP(2)-IP(3)
                updateJointData('thumb', 'mp', calculateAngle(lm[1], lm[2], lm[3]));
                // IP: MCP(2)-IP(3)-Tip(4)
                updateJointData('thumb', 'ip', calculateAngle(lm[2], lm[3], lm[4]));
            }
        }
        canvasCtx.restore();
    }

    function showResults() {
        resultPanel.style.display = 'block';
        let html = `<thead><tr><th>指</th><th>関節</th><th>屈曲</th><th>伸展</th><th>TAM</th></tr></thead><tbody>`;
        const t = fingersData.thumb;
        const t_tam = Math.max(0, t.joints.mp.flex - t.joints.mp.ext) + Math.max(0, t.joints.ip.flex - t.joints.ip.ext);
        html += `<tr class="finger-row"><td rowspan="3">${t.name}</td><td>CM</td><td>${t.joints.cm.flex}°</td><td>${t.joints.cm.ext}°</td><td>-</td></tr><tr class="finger-row"><td>MP</td><td>${t.joints.mp.flex}°</td><td>${t.joints.mp.ext}°</td><td rowspan="2">${t_tam}°</td></tr><tr class="finger-row"><td>IP</td><td>${t.joints.ip.flex}°</td><td>${t.joints.ip.ext}°</td></tr>`;
        
        ['index', 'middle', 'ring', 'pinky'].forEach(key => {
            const f = fingersData[key];
            const tam = Math.max(0, f.joints.mp.flex - f.joints.mp.ext) + Math.max(0, f.joints.pip.flex - f.joints.pip.ext) + Math.max(0, f.joints.dip.flex - f.joints.dip.ext);
            html += `<tr><td rowspan="3">${f.name}</td><td>MP</td><td>${f.joints.mp.flex}°</td><td>${f.joints.mp.ext}°</td><td rowspan="3">${tam}°</td></tr><tr><td>PIP</td><td>${f.joints.pip.flex}°</td><td>${f.joints.pip.ext}°</td></tr><tr><td>DIP</td><td>${f.joints.dip.flex}°</td><td>${f.joints.dip.ext}°</td></tr>`;
        });
        html += `</tbody>`;
        resultTableBody.innerHTML = html;
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(onResults);

    async function startCamera() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
            videoElement.srcObject = stream;
            videoElement.onloadedmetadata = () => {
                videoElement.play();
                const send = async () => { await hands.send({image: videoElement}); requestAnimationFrame(send); };
                send();
            };
        } catch (e) { alert("カメラエラー: " + e.message); }
    }
    startCamera();

    let wakeLock = null;
    async function requestWakeLock() { try { wakeLock = await navigator.wakeLock.request('screen'); } catch (err) {} }
    requestWakeLock();
    document.addEventListener('visibilitychange', async () => { if (wakeLock !== null && document.visibilityState === 'visible') await requestWakeLock(); });
</script>
</body>
</html>